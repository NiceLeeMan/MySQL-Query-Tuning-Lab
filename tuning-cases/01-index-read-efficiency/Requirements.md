# MySQL Indexing & Optimization Practice Requirements

이 문서는 `employees_bulk` 테이블을 활용하여 B-Tree 인덱스의 동작 원리, 스캔 방식의 차이, 그리고 옵티마이저의 선택 기준을 실험하고 검증하기 위한 요구사항 정의서이다.

## 실습 환경 및 전제 조건
* **Target Table:** `employees_bulk`
* **Initial State:** 모든 보조 인덱스(Secondary Index)를 삭제하고 PK만 남겨둔 상태에서 시작할 것.
* **Goal:** 각 요구사항별로 인덱스 생성 전후의 `EXPLAIN` 결과와 실행 시간(Duration)을 비교 분석하여 성능 차이를 체감한다.

---

## 1. 단순 데이터 조회 (Simple Lookup)
**요구사항:** 이름(`first_name`)이 'Georgi'인 직원의 **모든 정보**를 조회하시오.

> **Reason & Value**
> * **이유:** 가장 기본적인 조건 검색에서 인덱스 유무가 미치는 영향을 확인하기 위함.
> * **가치:** 300만 건을 모두 뒤지는 **풀 테이블 스캔(Full Table Scan, `type: ALL`)**과 B-Tree를 타고 특정 리프 노드만 접근하는 **`ref` 접근 방식**의 압도적인 성능 차이(I/O 비용 절감)를 체감한다.

## 2. 범위 검색 (Range Scan)
**요구사항:** 입사일(`hire_date`)이 '1990-01-01'부터 '1995-12-31' 사이인 직원의 **모든 정보**를 조회하시오.

> **Reason & Value**
> * **이유:** 단건 조회가 아닌 범위 조회 시 B-Tree가 어떻게 동작하는지 파악하기 위함.
> * **가치:** 인덱스 레인지 스캔(`type: range`)이 발생할 때, 시작점을 찾은 후 리프 노드의 연결 리스트(Linked List)를 타고 순차적으로 스캔하는 과정과, 그 과정에서 발생하는 **랜덤 I/O(데이터 파일 접근)**의 부하를 이해한다.

## 3. 커버링 인덱스 활용 (Covering Index - Best Case)
**요구사항:** 이름(`first_name`)이 'Matt'인 직원의 **사번(`emp_no`)만** 조회하시오.

> **Reason & Value**
> * **이유:** 쿼리에 필요한 모든 컬럼이 인덱스에 포함될 때의 동작을 확인하기 위함.
> * **가치:** 실행 계획의 `Extra: Using index`를 확인하여, **테이블(데이터 파일) 접근 없이 인덱스 페이지만 읽고 끝내는 방식**이 랜덤 I/O를 획기적으로 줄여주는 원리를 터득한다. (Double Look-up 방지)

## 4. 커버링 인덱스 실패 (Unintentional Double Look-up)
**요구사항:** 이름(`first_name`)이 'Matt'인 직원의 **성(`last_name`)을** 조회하시오. (인덱스는 `first_name`에만 걸려있다고 가정)

> **Reason & Value**
> * **이유:** 3번 요구사항과 조건은 동일하지만, 조회하려는 컬럼이 인덱스에 없을 때의 차이를 비교하기 위함.
> * **가치:** `Using index`가 사라지고 테이블 접근이 발생하는 것을 확인하며, 무분별한 `SELECT *` 사용이 왜 성능 저하(불필요한 랜덤 I/O 유발)를 일으키는지 명확히 이해한다.

## 5. 정렬 최적화 (Order By Optimization)
**요구사항:** 입사일(`hire_date`)이 빠른 순서대로 정렬하여 상위 10명의 정보를 조회하시오.

> **Reason & Value**
> * **이유:** 인덱스가 정렬(`ORDER BY`) 작업에 미치는 영향을 분석하기 위함.
> * **가치:** 인덱스가 없을 때 발생하는 **`Using filesort`**(CPU/메모리 비용이 큰 별도 정렬 작업)가, 인덱스 생성 후 어떻게 제거되는지 확인한다. B-Tree는 이미 정렬되어 있으므로 읽기만 하면 된다는 점을 검증한다.

## 6. 복합 인덱스와 컬럼 순서 (Leftmost Prefix Rule)
**요구사항:** `(first_name, last_name)` 순서로 복합 인덱스를 생성한 뒤, **성(`last_name`)이 'Baba'인 직원**을 조회하시오.

> **Reason & Value**
> * **이유:** 다중 컬럼 인덱스에서 컬럼의 순서가 검색 가능 여부를 결정한다는 것을 증명하기 위함.
> * **가치:** 선행 컬럼(`first_name`) 조건 없이 후행 컬럼(`last_name`)만으로는 인덱스를 정상적으로 탈 수 없음(또는 매우 비효율적임)을 확인하고, **Leftmost Prefix 규칙**의 중요성을 각인한다.

## 7. LIKE 패턴과 인덱스 효율성 (Prefix vs Suffix)
**요구사항:**
1. 이름이 'Geo'로 시작하는(`Geo%`) 직원 조회
2. 이름이 'orgi'로 끝나는(`%orgi`) 직원 조회

> **Reason & Value**
> * **이유:** 문자열 패턴 검색 시 와일드카드 위치에 따른 인덱스 사용 가능 여부를 비교하기 위함.
> * **가치:** B-Tree 인덱스는 왼쪽부터 정렬되어 있다는 특성 때문에, **접두사(Prefix) 일치**만 인덱스를 탈 수 있고 **접미사(Suffix) 일치**는 풀 스캔이 발생함을 눈으로 확인한다.

## 8. 인덱스 풀 스캔 (Index Full Scan)
**요구사항:** `WHERE` 조건 없이 전체 직원의 수(`COUNT`)를 구하시오.

> **Reason & Value**
> * **이유:** 옵티마이저가 테이블 풀 스캔 대신 인덱스 풀 스캔을 선택하는 상황을 관찰하기 위함.
> * **가치:** 데이터 파일(Clustered Index)보다 크기가 훨씬 작은 세컨더리 인덱스를 처음부터 끝까지 읽는 것이 성능상 유리하다는 **옵티마이저의 비용 계산 논리**를 이해한다.

## 9. 선택도와 기수성 (Selectivity & Cardinality)
**요구사항:** 성별(`gender`)이 'M'인 직원을 모두 조회하시오. (남자가 전체의 약 60%라고 가정)

> **Reason & Value**
> * **이유:** 인덱스가 있더라도 옵티마이저가 이를 사용하지 않는(무시하는) 케이스를 확인하기 위함.
> * **가치:** 읽어야 할 데이터가 전체의 일정 비율(약 20~25%)을 넘어가면, 인덱스를 타는 랜덤 I/O 비용보다 **테이블 풀 스캔의 순차 I/O 비용이 더 저렴하다**고 판단하는 옵티마이저의 똑똑함을 배운다.

## 10. 가공된 컬럼의 인덱스 미사용 (Index Invalidation)
**요구사항:** 입사일의 연도(`YEAR(hire_date)`)가 2000년인 직원을 조회하시오. (인덱스는 `hire_date`에 걸려있음)

> **Reason & Value**
> * **이유:** 인덱스 컬럼을 가공했을 때 B-Tree를 사용할 수 없는 현상을 확인하기 위함.
> * **가치:** 인덱스는 원본 값을 기준으로 정렬되어 있으므로, **함수나 연산으로 값을 변형하면 인덱스를 탈 수 없다**는 절대 원칙을 깨닫고 올바른 쿼리 작성법을 익힌다.